// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableSummary {
    /// The full name of the table.
    #[prost(string, tag="1")]
    pub full_name: ::prost::alloc::string::String,
    #[prost(enumeration="TableType", tag="2")]
    pub table_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnInfo {
    /// Name of the column
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Full data type specification as SQL/catalogString text.
    #[prost(string, tag="2")]
    pub type_text: ::prost::alloc::string::String,
    /// Full data type specification, JSON-serialized.
    #[prost(string, tag="3")]
    pub type_json: ::prost::alloc::string::String,
    /// Data type name.
    #[prost(enumeration="ColumnTypeName", tag="4")]
    pub type_name: i32,
    /// Digits of precision; required for DecimalTypes.
    #[prost(int32, optional, tag="5")]
    pub type_precision: ::core::option::Option<i32>,
    /// Digits to right of decimal; Required for DecimalTypes.
    #[prost(int32, optional, tag="6")]
    pub type_scale: ::core::option::Option<i32>,
    /// Format of IntervalType.
    #[prost(string, optional, tag="7")]
    pub type_interval_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Ordinal position of column (starting at position 0).
    #[prost(int32, optional, tag="8")]
    pub position: ::core::option::Option<i32>,
    /// User-provided free-form text description.
    #[prost(string, optional, tag="9")]
    pub comment: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether field may be Null.
    #[prost(bool, optional, tag="10")]
    pub nullable: ::core::option::Option<bool>,
    /// Partition index for column.
    #[prost(int32, optional, tag="11")]
    pub partition_index: ::core::option::Option<i32>,
    /// a unique id for the column
    #[prost(string, optional, tag="12")]
    pub column_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableInfo {
    /// Name of table, relative to parent schema.
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Name of parent schema.
    #[prost(string, tag="2")]
    pub schema_name: ::prost::alloc::string::String,
    /// Name of parent catalog.
    #[prost(string, tag="3")]
    pub catalog_name: ::prost::alloc::string::String,
    #[prost(enumeration="TableType", tag="4")]
    pub table_type: i32,
    /// Data source format of the table.
    #[prost(enumeration="DataSourceFormat", tag="5")]
    pub data_source_format: i32,
    /// The array of ColumnInfo definitions of the table's columns.
    #[prost(message, repeated, tag="6")]
    pub columns: ::prost::alloc::vec::Vec<ColumnInfo>,
    /// Storage root URL for table (for MANAGED, EXTERNAL tables)
    #[prost(string, optional, tag="7")]
    pub storage_location: ::core::option::Option<::prost::alloc::string::String>,
    // View definition SQL (when table_type is VIEW, MATERIALIZED_VIEW, or STREAMING_TABLE)
    // optional string view_definition = 8;

    // optional string view_dependencies = 9;

    // optional string sql_path = 10;

    /// Username of current owner of table.
    #[prost(string, optional, tag="11")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
    /// User-provided free-form text description.
    #[prost(string, optional, tag="12")]
    pub comment: ::core::option::Option<::prost::alloc::string::String>,
    /// A map of key-value properties attached to the securable.
    #[prost(message, optional, tag="13")]
    pub properties: ::core::option::Option<::pbjson_types::Struct>,
    /// Name of the storage credential, when a storage credential is configured for use with this table.
    #[prost(string, optional, tag="14")]
    pub storage_credential_name: ::core::option::Option<::prost::alloc::string::String>,
    // List of table constraints. Note: this field is not set in the output of the listTables API.
    // repeated TableConstraint constraints = 15;

    // optional string row_filter = 16;

    /// Full name of table, in form of catalog_name.schema_name.table_name.
    #[prost(string, optional, tag="17")]
    pub full_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Time at which this table was created, in epoch milliseconds.
    #[prost(int64, optional, tag="18")]
    pub created_at: ::core::option::Option<i64>,
    /// Username of table creator.
    #[prost(string, optional, tag="19")]
    pub created_by: ::core::option::Option<::prost::alloc::string::String>,
    /// Time at which this table was last updated, in epoch milliseconds.
    #[prost(int64, optional, tag="20")]
    pub updated_at: ::core::option::Option<i64>,
    /// Username of user who last modified table.
    #[prost(string, optional, tag="21")]
    pub updated_by: ::core::option::Option<::prost::alloc::string::String>,
    /// Time at which this table was deleted, in epoch milliseconds. Field is omitted if table is not deleted.
    #[prost(int64, optional, tag="22")]
    pub deleted_at: ::core::option::Option<i64>,
    /// Unique identifier for the table.
    #[prost(string, optional, tag="23")]
    pub table_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// The type of the table.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TableType {
    Unspecified = 0,
    Managed = 1,
    External = 2,
}
impl TableType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TableType::Unspecified => "TABLE_TYPE_UNSPECIFIED",
            TableType::Managed => "MANAGED",
            TableType::External => "EXTERNAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TABLE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MANAGED" => Some(Self::Managed),
            "EXTERNAL" => Some(Self::External),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataSourceFormat {
    Unspecified = 0,
    Delta = 1,
    Iceberg = 2,
    Hudi = 3,
    Parquet = 4,
    Csv = 5,
    Json = 6,
    Orc = 7,
    Avro = 8,
    Text = 9,
    UnityCatalog = 10,
    Deltasharing = 11,
}
impl DataSourceFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DataSourceFormat::Unspecified => "DATA_SOURCE_FORMAT_UNSPECIFIED",
            DataSourceFormat::Delta => "DELTA",
            DataSourceFormat::Iceberg => "ICEBERG",
            DataSourceFormat::Hudi => "HUDI",
            DataSourceFormat::Parquet => "PARQUET",
            DataSourceFormat::Csv => "CSV",
            DataSourceFormat::Json => "JSON",
            DataSourceFormat::Orc => "ORC",
            DataSourceFormat::Avro => "AVRO",
            DataSourceFormat::Text => "TEXT",
            DataSourceFormat::UnityCatalog => "UNITY_CATALOG",
            DataSourceFormat::Deltasharing => "DELTASHARING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_SOURCE_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "DELTA" => Some(Self::Delta),
            "ICEBERG" => Some(Self::Iceberg),
            "HUDI" => Some(Self::Hudi),
            "PARQUET" => Some(Self::Parquet),
            "CSV" => Some(Self::Csv),
            "JSON" => Some(Self::Json),
            "ORC" => Some(Self::Orc),
            "AVRO" => Some(Self::Avro),
            "TEXT" => Some(Self::Text),
            "UNITY_CATALOG" => Some(Self::UnityCatalog),
            "DELTASHARING" => Some(Self::Deltasharing),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ColumnTypeName {
    Unspecified = 0,
    Boolean = 1,
    Byte = 2,
    Short = 3,
    Int = 4,
    Long = 5,
    Float = 6,
    Double = 7,
    Date = 8,
    Timestamp = 9,
    String = 10,
    Binary = 11,
    Decimal = 12,
    Interval = 13,
    Array = 14,
    Struct = 15,
    Map = 16,
    Char = 17,
    Null = 18,
    UserDefinedType = 19,
    TimestampNtz = 20,
    Variant = 21,
    TableType = 22,
}
impl ColumnTypeName {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ColumnTypeName::Unspecified => "COLUMN_TYPE_NAME_UNSPECIFIED",
            ColumnTypeName::Boolean => "BOOLEAN",
            ColumnTypeName::Byte => "BYTE",
            ColumnTypeName::Short => "SHORT",
            ColumnTypeName::Int => "INT",
            ColumnTypeName::Long => "LONG",
            ColumnTypeName::Float => "FLOAT",
            ColumnTypeName::Double => "DOUBLE",
            ColumnTypeName::Date => "DATE",
            ColumnTypeName::Timestamp => "TIMESTAMP",
            ColumnTypeName::String => "STRING",
            ColumnTypeName::Binary => "BINARY",
            ColumnTypeName::Decimal => "DECIMAL",
            ColumnTypeName::Interval => "INTERVAL",
            ColumnTypeName::Array => "ARRAY",
            ColumnTypeName::Struct => "STRUCT",
            ColumnTypeName::Map => "MAP",
            ColumnTypeName::Char => "CHAR",
            ColumnTypeName::Null => "NULL",
            ColumnTypeName::UserDefinedType => "USER_DEFINED_TYPE",
            ColumnTypeName::TimestampNtz => "TIMESTAMP_NTZ",
            ColumnTypeName::Variant => "VARIANT",
            ColumnTypeName::TableType => "TABLE_TYPE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COLUMN_TYPE_NAME_UNSPECIFIED" => Some(Self::Unspecified),
            "BOOLEAN" => Some(Self::Boolean),
            "BYTE" => Some(Self::Byte),
            "SHORT" => Some(Self::Short),
            "INT" => Some(Self::Int),
            "LONG" => Some(Self::Long),
            "FLOAT" => Some(Self::Float),
            "DOUBLE" => Some(Self::Double),
            "DATE" => Some(Self::Date),
            "TIMESTAMP" => Some(Self::Timestamp),
            "STRING" => Some(Self::String),
            "BINARY" => Some(Self::Binary),
            "DECIMAL" => Some(Self::Decimal),
            "INTERVAL" => Some(Self::Interval),
            "ARRAY" => Some(Self::Array),
            "STRUCT" => Some(Self::Struct),
            "MAP" => Some(Self::Map),
            "CHAR" => Some(Self::Char),
            "NULL" => Some(Self::Null),
            "USER_DEFINED_TYPE" => Some(Self::UserDefinedType),
            "TIMESTAMP_NTZ" => Some(Self::TimestampNtz),
            "VARIANT" => Some(Self::Variant),
            "TABLE_TYPE" => Some(Self::TableType),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTableSummariesRequest {
    /// Name of parent catalog for tables of interest.
    #[prost(string, tag="1")]
    pub catalog_name: ::prost::alloc::string::String,
    /// A sql LIKE pattern (% and _) for schema names. All schemas will be returned if not set or empty.
    #[prost(string, optional, tag="2")]
    pub schema_name_pattern: ::core::option::Option<::prost::alloc::string::String>,
    /// A sql LIKE pattern (% and _) for table names. All tables will be returned if not set or empty.
    #[prost(string, optional, tag="3")]
    pub table_name_pattern: ::core::option::Option<::prost::alloc::string::String>,
    /// The maximum number of results per page that should be returned.
    #[prost(int32, optional, tag="100")]
    pub max_results: ::core::option::Option<i32>,
    /// Opaque pagination token to go to next page based on previous query.
    #[prost(string, optional, tag="101")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether to include a manifest containing capabilities the table has.
    #[prost(bool, optional, tag="102")]
    pub include_manifest_capabilities: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTableSummariesResponse {
    /// The table summaries returned.
    #[prost(message, repeated, tag="1")]
    pub tables: ::prost::alloc::vec::Vec<TableSummary>,
    /// The next_page_token value to include in the next List request.
    #[prost(string, optional, tag="2")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTablesRequest {
    /// Name of parent schema for tables of interest.
    #[prost(string, tag="1")]
    pub schema_name: ::prost::alloc::string::String,
    /// Name of parent catalog for tables of interest.
    #[prost(string, tag="2")]
    pub catalog_name: ::prost::alloc::string::String,
    /// The maximum number of results per page that should be returned.
    #[prost(int32, optional, tag="3")]
    pub max_results: ::core::option::Option<i32>,
    /// Opaque pagination token to go to next page based on previous query.
    #[prost(string, optional, tag="4")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether delta metadata should be included in the response.
    #[prost(bool, optional, tag="5")]
    pub include_delta_metadata: ::core::option::Option<bool>,
    /// Whether to omit the columns of the table from the response or not.
    #[prost(bool, optional, tag="6")]
    pub omit_columns: ::core::option::Option<bool>,
    /// Whether to omit the properties of the table from the response or not.
    #[prost(bool, optional, tag="7")]
    pub omit_properties: ::core::option::Option<bool>,
    /// Whether to omit the username of the table (e.g. owner, updated_by, created_by) from the response or not.
    #[prost(bool, optional, tag="8")]
    pub omit_username: ::core::option::Option<bool>,
    /// Whether to include tables in the response for which the principal can only access selective metadata for
    #[prost(bool, optional, tag="9")]
    pub include_browse: ::core::option::Option<bool>,
    /// Whether to include a manifest containing capabilities the table has.
    #[prost(bool, optional, tag="10")]
    pub include_manifest_capabilities: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTablesResponse {
    /// The tables returned.
    #[prost(message, repeated, tag="1")]
    pub tables: ::prost::alloc::vec::Vec<TableInfo>,
    /// The next_page_token value to include in the next List request.
    #[prost(string, optional, tag="2")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
}
/// Create a table
///
/// WARNING: this API is experimental and subject to change.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTableRequest {
    /// Name of table, relative to parent schema.
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Name of parent schema relative to its parent catalog.
    #[prost(string, tag="2")]
    pub schema_name: ::prost::alloc::string::String,
    /// Name of parent catalog.
    #[prost(string, tag="3")]
    pub catalog_name: ::prost::alloc::string::String,
    #[prost(enumeration="TableType", tag="4")]
    pub table_type: i32,
    #[prost(enumeration="DataSourceFormat", tag="5")]
    pub data_source_format: i32,
    /// The array of ColumnInfo definitions of the table's columns.
    #[prost(message, repeated, tag="6")]
    pub columns: ::prost::alloc::vec::Vec<ColumnInfo>,
    /// Storage root URL for external table.
    #[prost(string, optional, tag="7")]
    pub storage_location: ::core::option::Option<::prost::alloc::string::String>,
    /// User-provided free-form text description.
    #[prost(string, optional, tag="8")]
    pub comment: ::core::option::Option<::prost::alloc::string::String>,
    /// A map of key-value properties attached to the securable.
    #[prost(message, optional, tag="9")]
    pub properties: ::core::option::Option<::pbjson_types::Struct>,
}
/// Get a table
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTableRequest {
    /// Full name of the table.
    #[prost(string, tag="1")]
    pub full_name: ::prost::alloc::string::String,
    /// Whether delta metadata should be included in the response.
    #[prost(bool, optional, tag="2")]
    pub include_delta_metadata: ::core::option::Option<bool>,
    /// Whether to include tables in the response for which the principal can only access selective metadata for
    #[prost(bool, optional, tag="3")]
    pub include_browse: ::core::option::Option<bool>,
    /// Whether to include a manifest containing capabilities the table has.
    #[prost(bool, optional, tag="4")]
    pub include_manifest_capabilities: ::core::option::Option<bool>,
}
/// Get boolean reflecting if table exists
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTableExistsRequest {
    /// Full name of the table.
    #[prost(string, tag="1")]
    pub full_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTableExistsResponse {
    /// Boolean reflecting if table exists.
    #[prost(bool, tag="1")]
    pub table_exists: bool,
}
/// Delete a table
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTableRequest {
    /// Full name of the table.
    #[prost(string, tag="1")]
    pub full_name: ::prost::alloc::string::String,
}
include!("delta_sharing.tables.v1.serde.rs");
// @@protoc_insertion_point(module)